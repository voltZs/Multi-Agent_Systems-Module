package mas.coursework;

import java.util.ArrayList;
import java.util.HashMap;

import jade.content.onto.OntologyException;
import mas.coursework_ontology.elements.SellPhones;

public class PhoneOrdersManager {

	private HashMap<SellPhones, Integer> phoneOrders;
	
	public PhoneOrdersManager(){
		phoneOrders = new HashMap<>();
	}
	
	public void addOrder(SellPhones order){
		phoneOrders.put(order, 0);
	}

	public void incrementNewDay() {
		for(SellPhones phoneOrder : phoneOrders.keySet()){
			int currentAmnt = phoneOrders.get(phoneOrder);
			phoneOrders.put(phoneOrder, currentAmnt + 1);
		}
	}
	
	/*
	 * This is to be called before a new day is incremented, and after all orders have been shipped for the day
	 */
	public Double calculateLateOrders(){
		Double penalty = 0.0;
		for(SellPhones phoneOrder : phoneOrders.keySet()){
			int due = phoneOrder.getDaysDue();
			int dailyPenalty = phoneOrder.getPerDayPenalty();
			int currentDay = phoneOrders.get(phoneOrder);
//			including the due day as this method is to be called after the orders for the day have been shipped - meaning there's a penalty for "today"
			if(currentDay >= due){
				penalty += (currentDay-due+1) * dailyPenalty;
			}
		}
		return penalty;
	}

	public String ordersToString() {
		String result = "";
		for(SellPhones order : phoneOrders.keySet()){
			int overdue = (phoneOrders.get(order) - order.getDaysDue());
			result += "Phone Order:\n" + "\tPending:" + phoneOrders.get(order) + "\n";
			result += "Overdue: " + overdue + "\n";
			result += "Due: " + order.getDaysDue() + "\n";
			result += "PerDayPenalty: " + order.getPerDayPenalty() + "\n";
			result += "Penalty now: " + (order.getPerDayPenalty() * overdue) + "\n";
			result += "\tPhone:\n";
			try {
				result += "\tscreen: " + order.getPhone().getScreen() + "\n";
				result += "\tbattery: " + order.getPhone().getBattery()+ "\n";
			} catch (OntologyException e) {
				e.printStackTrace();
			}
			result += "\tram:" + order.getPhone().getRam() + "\n";
			result += "\tstorage: " + order.getPhone().getStorage() + "\n";
		}
		return result;
	}
	
	public Double calculateUrgency(SellPhones order){
		
		return 1.0;
	}
	
	public HashMap<SellPhones, Double> generateUrgencyMatrix(ArrayList<SellPhones> orders){
		HashMap<SellPhones, Double> matrix = new HashMap<>();
		for(SellPhones order : orders){
			matrix.put(order, calculateUrgency(order));
		}
		return matrix;
	}
	
	public void matrixToString(HashMap<SellPhones, Double> matrix){
		for(SellPhones order : matrix.keySet()){
			System.out.println("\t"+ order + " - urgency: " + matrix.get(order));
		}
	}
}
